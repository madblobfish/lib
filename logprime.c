#include <stdlib.h>
#include <stdio.h> // printf() n stuff
//#include <math.h> //for sqrt()
#include <time.h> //for clock() and CLK_TCK
#include <string.h> //for strncmp() and strtol

#define PUT(X) fputs(X, stdout)
//#define Bit64

// meine schnellsten zeiten
// ???

inline unsigned int isqrt(unsigned int num){
	unsigned int res = 0;
	unsigned int bit = 1 << 31; // The second-to-top bit is set: 1 << 30 for 32 bits

	// "bit" starts at the highest power of four <= the argument.
	while(bit > num){
		bit >>= 2;
	}

	while(bit != 0){
		if(num >= res + bit){
			num -= res + bit;
			res = (res >> 1) + bit;
		}else{
			res >>= 1;
		}
		bit >>= 2;
	}
	return res;
}

unsigned int ilog2(const unsigned int value){
	unsigned int v = value;  // 32-bit value to find the log2 of
	const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};
	const unsigned int S[] = {1, 2, 4, 8, 16};
	int i;

	register unsigned int r = 0; // result of log2(v) will go here
	for(i = 4; i >= 0; i--){
		if(v & b[i]){
			v >>= S[i];
			r |= S[i];
		}
	}
	return r;
}

char* itobzs(const unsigned int number, const unsigned char b, const char z){
	unsigned int num = number;
	char alphabet[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	unsigned int len;
	char* out;

	if(b>35){ return (char*)"0"; }
	if(num < 1 && !z){ return (char*)"0"; }

	if(z){ len = (ilog2(1<<31) / ilog2((unsigned int)b)) + 1; }
	else { len = (ilog2(num)   / ilog2((unsigned int)b)) + 1; }
	out = (char*) malloc( sizeof(char)*len );

	out[len-1] = '\0';
	if(num > 1){
		while(num > 0){
			out[len-1] = alphabet[num%b];
			num /= b;
			len--;
		}
	}
	while(len > 0){
		out[len-1] = '0';
		len--;
	}
	return out;
}
char* itos(const unsigned int number){return itobzs(number, 10, 0);}
char* itobs(const unsigned int number, const unsigned char b){return itobzs(number, b, 0);}

// unsigned int genpart(const unsigned int, const unsigned int){
//	const unsigned int pat[] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80,
//								0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000,
//								0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000, 0x800000,
//								0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000, 0x20000000, 0x40000000}
// }

int main(int argc, char const *argv[]){
	// flags
	char bin = 0;
	char calc = 0;
	char print = 1;
	char getnum = 0;

	// vars
	unsigned int length = 1000;
	unsigned int storageSize = 0;
	unsigned int max;
	unsigned int i;
	unsigned int t;

	for(i = 1; i < argc; ++i){
		if(argc < 2 || !strcmp(argv[i], "-h") || !strcmp(argv[1], "--help")){
			PUT(  "Usage: " );
			PUT(  argv[0] );
			puts( " [options] <maximum primes>\n" );
			puts( "  -h               Display this Help" );
			puts( " --help            Display this Help\n" );

			puts( "  -v               Display Version" );
			puts( " --version         Display Version\n" );

			puts( "  -n               Output (base 10)" );
			puts( "  -b               Output (base 2)\n" );

			puts( "  -t               Insert Calculation Time in Output" );
			puts( "  -T               Only output the Calculation Time\n" );

			puts( "Copyright Information:" );
			puts( "Use as you like, it's yours" );
			puts( "No Warranties and Limitation of Liability" );
			return 0;
		}else if(!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version")){
			puts( "Version 0.0.1 of BitPrimeSieve\nWritten By Killerwolf" );
			return 0;
		}else if(!strcmp(argv[i], "-t")){
			calc = 1;
		}else if(!strcmp(argv[i], "-n")){
			getnum = 1;
		}else if(!strcmp(argv[i], "-b")){
			getnum = 1;
			bin = 1;
		}else if(!strcmp(argv[i], "-T")){
			getnum = 0;
			print = 0;
			calc = 1;
		}else if(strtol(&argv[i][0], NULL, 10)){
			length = atoi(&argv[i][0]);
			break;
		};
	};

	max = (unsigned int)isqrt(length);
	length /= (32);	// 64 = 2*32 = (half size and integer bitnumber)
	length += 1;

	storageSize = length;
	unsigned int storage[length];
	memset(storage, 0, sizeof(storage)); // init storage to zero

	t = clock();
	i = 0;

	while(i++ < max){
		puts(itos(i));
	}

	t = clock() - t;

	if(print){
		i = length;
		PUT("[2");
		// while(--i > 0){
		// 	if(!mpz_tstbit(primes, i)){
		// 	puts(itos(2*(length-i)+1)); //	printf(", %d", 2*(length-i)+1);
		// 	}
		// }
		puts("]");
	}

	if(getnum){
		i = 0;
		while(i < storageSize){
			if(bin){
				PUT(itobzs(storage[i], 2, 1));
			}else{
				PUT(itobs(storage[i], 10)); PUT(" ");
			}
			i++;
		}
		puts("");
		//puts(mpz_get_str(NULL, 2, primes));
	}

	if(calc){
		PUT("Calctime: ");
		PUT(itos(t));
		PUT(" clicks (");
		//printf("%.5f", ( (double)t / (double)CLOCKS_PER_SEC ) );
		puts(" seconds)");
	};


	// FREE MEMORY
	// free(storage);

	return 0;
}


/*

1  -  0 - 0001
2  -  2 - 0010
3  -  0 - 0011
4  -  4 - 0100
5  -  2 - 0101
6  -  6 - 0110
7  -  0 - 0111
8  -  8 - 1000
9  -  4 - 1001
10 - 10 - 1010
11 -  2 - 1011
12 - 12 - 1100
13 -  6 - 1101
14 - 14 - 1110
15 -  0 - 1111
16 - 16 -10000

12345678901234567890123456789012
01010101010101010101010101010101 01010101010101010101010101010101 01010101010101010101010101010101
00100100100100100100100100100100 10010010010010010010010010010010 01001001001001001001001001001001
00010001000100010001000100010001 00010001000100010001000100010001 00010001000100010001000100010001
00001000010000100001000010000100 00100001000010000100001000010000 10000100001000010000100001000010
00000100000100000100000100000100 00010000010000010000010000010000 01000001000001000001000001000001
00000010000001000000100000010000 00100000010000001000000100000010 00000100000010000001000000100000
00000001000000010000000100000001 00000001000000010000000100000001 00000001000000010000000100000001
00000000100000000100000000100000 00010000000010000000010000000010 00000001000000001000000001000000
00000000010000000001000000000100 00000001000000000100000000010000 00000100000000010000000001000000
00000000001000000000010000000000 10000000000100000000001000000000 01000000000010000000000100000000
00000000000100000000000100000000 00010000000000010000000000010000 00000001000000000001000000000001
00000000000010000000000001000000 00000010000000000001000000000000 10000000000001000000000000100000
00000000000001000000000000010000 00000000010000000000000100000000 00000100000000000001000000000000

01010101010101010101010101010101 01010101010101010101010101010101 01010101010101010101010101010101
00100100100100100100100100100100 10010010010010010010010010010010 01001001001001001001001001001001
00010001000100010001000100010001 00010001000100010001000100010001 00010001000100010001000100010001
00010000100001000010000100001000 01000010000100001000010000100001 00001000010000100001000010000100
00000100000100000100000100000100 00010000010000010000010000010000 01000001000001000001000001000001
01000000100000010000001000000100 00001000000100000010000001000000 10000001000000100000010000001000
00000001000000010000000100000001 00000001000000010000000100000001 00000001000000010000000100000001
00100000000100000000100000000100 00000010000000010000000010000000 01000000001000000001000000001000
00010000000001000000000100000000 01000000000100000000010000000001 00000000010000000001000000000100
00100000000001000000000010000000 00010000000000100000000001000000 00001000000000010000000000100000
00000000000100000000000100000000 00010000000000010000000000010000 00000001000000000001000000000001
00000001000000000000100000000000 01000000000000100000000000010000 00000000100000000000010000000000
01000000000000010000000000000100 00000000000100000000000001000000 00000001000000000000010000000000

01010101010101010101010101010101 01010101010101010101010101010101 01010101010101010101010101010101
00100100100100100100100100100100 10010010010010010010010010010010 01001001001001001001001001001001
00010001000100010001000100010001 00010001000100010001000100010001 00010001000100010001000100010001
00100001000010000100001000010000 10000100001000010000100001000010 00010000100001000010000100001000
00000100000100000100000100000100 00010000010000010000010000010000 01000001000001000001000001000001
00010000001000000100000010000001 00000010000001000000100000010000 00100000010000001000000100000010
00000001000000010000000100000001 00000001000000010000000100000001 00000001000000010000000100000001
00000100000000100000000100000000 10000000010000000010000000010000 00001000000001000000001000000001
00000001000000000100000000010000 00000100000000010000000001000000 00010000000001000000000100000000
00000100000000001000000000010000 00000010000000000100000000001000 00000001000000000010000000000100
00000000000100000000000100000000 00010000000000010000000000010000 00000001000000000001000000000001
00100000000000010000000000001000 00000000010000000000001000000000 00010000000000001000000000000100
00010000000000000100000000000001 00000000000001000000000000010000 00000000010000000000000100000000

00000000100000000100000000100000 00010000000010000000010000000010 00000001000000001000000001000000 00
01000000000100000000010000000001 00000000010000000001000000000100 00000001000000000100000000010000 000001
00000000100000000001000000000010 00000000010000000000100000000001 00000000001000000000010000000000
00000000000100000000000100000000 00010000000000010000000000010000 00000001000000000001000000000001
00000000001000000000000100000000 00001000000000000100000000000010 00000000000100000000000010000000
00000100000000000001000000000000 01000000000000010000000000000100 00000000000100000000000001000000

1
0
00000100000000000010000000000001 00000000000010000000000001000000 000000100000000000010000000000001
00000001000000000000010000000000 00010000000000000100000000000001 000000000000010000000000000100000 000000001


*/